<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CyberGlobe - Unified Geometry</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; width: 100vw; height: 100vh; outline: none; cursor: crosshair; }
        
        #ui-container {
            position: absolute; top: 20px; left: 20px;
            color: #00ffcc; pointer-events: none; z-index: 10;
            text-shadow: 0 0 5px rgba(0, 255, 204, 0.6);
        }
        h1 { margin: 0; font-size: 1.3rem; text-transform: uppercase; letter-spacing: 2px; }
        p { margin: 5px 0; font-size: 0.8rem; opacity: 0.9; color: #aaddff; }
        .badge { 
            display: inline-block; padding: 2px 6px; 
            background: rgba(0, 255, 204, 0.15); 
            border: 1px solid #00ffcc; 
            font-size: 0.7rem; margin-left: 10px; border-radius: 3px;
            box-shadow: 0 0 10px rgba(0,255,204,0.2);
            font-weight: bold;
        }

        #country-label {
            position: absolute;
            background: rgba(0, 10, 20, 0.9);
            border: 1px solid #00ffcc;
            color: #00ffcc;
            padding: 8px 12px;
            font-size: 0.8rem;
            pointer-events: none;
            display: none;
            transform: translate(-50%, -150%);
            white-space: nowrap;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.3);
            border-radius: 2px;
            z-index: 20;
        }
        #country-label::after {
            content: ''; position: absolute; bottom: -5px; left: 50%; margin-left: -5px;
            border-width: 5px 5px 0; border-style: solid; border-color: #00ffcc transparent; display: block; width: 0;
        }

        #cockpit {
            position: absolute; top: 20px; right: 20px; width: 320px; max-height: 90vh;
            background: rgba(0, 5, 10, 0.95);
            border: 1px solid rgba(0, 255, 204, 0.4);
            padding: 15px; border-radius: 4px;
            color: #fff; font-size: 0.75rem; pointer-events: auto;
            backdrop-filter: blur(15px);
            box-shadow: -10px 10px 40px rgba(0, 0, 0, 0.8);
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #00ffcc #001122;
            transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
        }
        #cockpit::-webkit-scrollbar { width: 6px; }
        #cockpit::-webkit-scrollbar-track { background: #001122; }
        #cockpit::-webkit-scrollbar-thumb { background-color: #00ffcc; border-radius: 3px; }

        .cockpit-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 15px; padding-bottom: 5px; border-bottom: 1px solid #00ffcc;
        }
        .section-title {
            color: #00ffcc; font-weight: bold; margin-top: 15px; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;
            border-left: 2px solid #00ffcc; padding-left: 8px;
        }
        .control-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
        label { color: #aaddff; width: 110px; text-align: right; margin-right: 10px; }
        input[type="range"] { flex-grow: 1; accent-color: #00ffcc; cursor: pointer; height: 4px; }
        input[type="color"] { border: none; width: 30px; height: 20px; cursor: pointer; background: none; }
        
        button.toggle-ui {
            position: absolute; top: 20px; right: 20px;
            background: #003344; border: 1px solid #00ffcc; color: #00ffcc;
            padding: 8px 15px; cursor: pointer; z-index: 5; text-transform: uppercase; font-weight: bold;
        }
        button.toggle-ui:hover { background: #00ffcc; color: #000; }
        .value-display { color: #00ffcc; width: 30px; text-align: right; font-family: monospace;}

        .hidden { transform: translateX(120%); pointer-events: none; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/earcut@2.2.3/dist/earcut.min.js"></script>
</head>
<body>

<button class="toggle-ui"
        onclick="document.getElementById('cockpit').classList.toggle('hidden')">
    UI
</button>

<div id="ui-container">
    <h1>CyberGlobe <span class="badge">UNIFIED</span></h1>
    <p>FPS: <span id="fps">0</span></p>
</div>

<div id="country-label">Country</div>

<!-- LE COCKPIT -->
<div id="cockpit">
    <div class="cockpit-header">
        <span>SYSTEM CONTROLS</span>
        <span style="color:#00ffcc">V2.1</span>
    </div>

    <!-- GEOMETRY -->
    <div class="section-title">Geometry</div>

    <div class="control-row">
        <label>Extrusion H</label>
        <input type="range" id="geo-extrude" min="0.0" max="0.5" step="0.01" value="0.12">
        <span class="value-display" id="val-geo-extrude">0.12</span>
    </div>

    <div class="control-row">
        <label>Globe Radius</label>
        <input type="range" id="geo-radius" min="3" max="10" step="0.1" value="5">
        <span class="value-display" id="val-geo-radius">5.0</span>
    </div>

    <div class="control-row">
        <label>Atmo Radius</label>
        <input type="range" id="geo-atmo-rad" min="0.5" max="2.0" step="0.1" value="0.8">
        <span class="value-display" id="val-geo-atmo-rad">0.8</span>
    </div>

    <!-- GLASS MATERIAL -->
    <div class="section-title">Glass Material</div>

    <div class="control-row">
        <label>Transmission</label>
        <input type="range" id="glass-trans" min="0" max="0.99" step="0.01" value="0.6">
        <span class="value-display" id="val-glass-trans">0.60</span>
    </div>

    <div class="control-row">
        <label>Roughness</label>
        <input type="range" id="glass-rough" min="0" max="1" step="0.01" value="0.1">
        <span class="value-display" id="val-glass-rough">0.10</span>
    </div>

    <div class="control-row">
        <label>Metalness</label>
        <input type="range" id="glass-metal" min="0" max="1" step="0.01" value="0.2">
        <span class="value-display" id="val-glass-metal">0.20</span>
    </div>

    <div class="control-row">
        <label>Clearcoat</label>
        <input type="range" id="glass-clear" min="0" max="1" step="0.01" value="1.0">
        <span class="value-display" id="val-glass-clear">1.00</span>
    </div>

    <!-- ATMOSPHERE -->
    <div class="section-title">Atmosphere</div>

    <div class="control-row">
        <label>Intensity</label>
        <input type="range" id="corona-int" min="0" max="5" step="0.1" value="1.5">
        <span class="value-display" id="val-corona-int">1.5</span>
    </div>

    <div class="control-row">
        <label>Color Out</label>
        <input type="color" id="corona-col1" value="#917c12">
    </div>

    <!-- LIGHTING -->
    <div class="section-title">Lighting</div>

    <div class="control-row">
        <label>Sun Intensity</label>
        <input type="range" id="light-sun-int" min="0" max="3" step="0.1" value="1.2">
        <span class="value-display">1.2</span>
    </div>

    <div class="control-row">
        <label>Sun Color</label>
        <input type="color" id="light-sun-col" value="#ffffff">
    </div>

    <div class="control-row">
        <label>Rim Intensity</label>
        <input type="range" id="light-rim-int" min="0" max="10" step="0.1" value="4.0">
        <span class="value-display">4.0</span>
    </div>

    <div class="control-row">
        <label>Rim Color</label>
        <input type="color" id="light-rim-col" value="#00ffff">
    </div>

    <div class="control-row">
        <label>Ambient Int</label>
        <input type="range" id="light-amb-int" min="0" max="1" step="0.05" value="0.15">
        <span class="value-display">0.15</span>
    </div>

    <!-- CAMERA / ENV -->
    <div class="section-title">Camera & Env</div>

    <div class="control-row">
        <label>Fog Density</label>
        <input type="range" id="env-fog" min="0" max="0.05" step="0.001" value="0.005">
        <span class="value-display">0.005</span>
    </div>

    <div class="control-row">
        <label>Rotation Spd</label>
        <input type="range" id="env-rot" min="0" max="0.005" step="0.0001" value="0.005">
        <span class="value-display">0.005</span>
    </div>

    <div class="control-row">
        <label>FOV</label>
        <input type="range" id="cam-fov" min="20" max="100" step="1" value="35">
        <span class="value-display">35</span>
    </div>
</div>

<script>
/* ------------------------------------------------------------
   CONFIG
------------------------------------------------------------ */
const CONFIG = {
  radius: 5,
  extrudeDepth: 0.12,
  colorOcean: 0x020205,
  colorGlow: 0x00ffcc,
  geoJsonUrl: "https://raw.githubusercontent.com/johan/world.geo.json/master/countries.geo.json",
  autoRotate: true,
  rotateSpeed: 0.0005,
  borderOffset: 0.1 // offset radial pour les lignes (overlay)
};

/* ------------------------------------------------------------
   SCENE
------------------------------------------------------------ */
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.015);

const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 16;
camera.position.y = 4;

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.setClearColor(0x000000);
document.body.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.enablePan = false;
controls.minDistance = 6;
controls.maxDistance = 30;

/* ------------------------------------------------------------
   INTERACTION
------------------------------------------------------------ */
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
const hoveredMeshes = new Set();
const labelEl = document.getElementById("country-label");

function onMouseMove(event) {
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
}
window.addEventListener("mousemove", onMouseMove);

/* ------------------------------------------------------------
   LIGHTING
------------------------------------------------------------ */
const ambientLight = new THREE.AmbientLight(0xffffff, 0.15);
scene.add(ambientLight);

const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
sunLight.position.set(10, 10, 10);
scene.add(sunLight);

const blueLight = new THREE.DirectionalLight(0x0088ff, 0.5);
blueLight.position.set(-5, 0, 5);
scene.add(blueLight);

const rimLight = new THREE.SpotLight(0x00ffff, 4.0);
rimLight.position.set(-15, 5, -10);
rimLight.lookAt(0, 0, 0);
scene.add(rimLight);

/* ------------------------------------------------------------
   SHADERS
------------------------------------------------------------ */
const starsVS = `
  attribute float size;
  void main() {
    gl_PointSize = size;
    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    gl_Position = projectionMatrix * mvPosition;
  }
`;
const starsFS = `
  uniform vec3 color;
  void main() {
    vec2 coord = gl_PointCoord - vec2(0.5);
    if(length(coord) > 0.5) discard;
    gl_FragColor = vec4(color, 1.0);
  }
`;

const coronaVS = `
  varying vec3 v_normal;
  void main() {
    v_normal = normalize(normalMatrix * normal);
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;
/* NOTE: on a supprimé color0 + noiseSpeed (UI supprimée).
   On garde uniquement color1 + intensity + time (time conservé même si pas utilisé, stable). */
const coronaFS = `
  varying vec3 v_normal;
  uniform vec3 color1;
  uniform float intensity;
  uniform float time;
  void main() {
    float viewAngle = dot(v_normal, vec3(0,0,1));
    float glow = pow(0.6 - viewAngle, 2.5);
    vec3 finalColor = mix(vec3(0.0), color1, glow);
    gl_FragColor = vec4(finalColor, 1.0) * glow * intensity;
  }
`;

/* ------------------------------------------------------------
   MATERIALS
------------------------------------------------------------ */
const baseCountryMaterial = new THREE.MeshPhysicalMaterial({
  color: 0x00ffcc,
  metalness: 0.2,
  roughness: 0.1,
  transmission: 0.6,
  clearcoat: 1.0,
  clearcoatRoughness: 0.0,
  side: THREE.DoubleSide,
  transparent: true,
  polygonOffset: true,
  polygonOffsetFactor: 1,
  polygonOffsetUnits: 1,
  emissive: 0x000000,
  emissiveIntensity: 0
});

const oceanMat = new THREE.MeshPhysicalMaterial({
  color: 0x020408,
  metalness: 0.5,
  roughness: 0.4,
  clearcoat: 0.3
});

const coronaMaterial = new THREE.ShaderMaterial({
  vertexShader: coronaVS,
  fragmentShader: coronaFS,
  uniforms: {
    color1: { value: new THREE.Color(0x917c12) }, // correspond au HTML par défaut
    intensity: { value: 1.5 },
    time: { value: 0 }
  },
  side: THREE.BackSide,
  blending: THREE.AdditiveBlending,
  transparent: true,
  depthWrite: false
});

const borderMaterial = new THREE.LineBasicMaterial({
  color: 0x00ffff,
  transparent: true,
  opacity: 0.8,
  linewidth: 1
});

/* ------------------------------------------------------------
   GLOBE BASE
------------------------------------------------------------ */
const globeGroup = new THREE.Group();
scene.add(globeGroup);

let ocean = new THREE.Mesh(
  new THREE.SphereGeometry(CONFIG.radius - 0.02, 64, 64),
  oceanMat
);
globeGroup.add(ocean);

let atmosphere = new THREE.Mesh(
  new THREE.SphereGeometry(CONFIG.radius + 0.8, 64, 64),
  coronaMaterial
);
scene.add(atmosphere);

/* ------------------------------------------------------------
   GEOMETRY UTILS
------------------------------------------------------------ */
function lonLatToVector3(lon, lat, radius) {
  const phi = (90 - lat) * (Math.PI / 180);
  const theta = (lon + 180) * (Math.PI / 180);
  const x = -(radius * Math.sin(phi) * Math.cos(theta));
  const z = (radius * Math.sin(phi) * Math.sin(theta));
  const y = (radius * Math.cos(phi));
  return new THREE.Vector3(x, y, z);
}

function createPrismExtrusion(ring, R, height) {
  const basePoints = [];
  ring.forEach(([lon, lat]) => basePoints.push(lonLatToVector3(lon, lat, R)));

  const centroid = new THREE.Vector3();
  basePoints.forEach(v => centroid.add(v));
  centroid.divideScalar(basePoints.length);

  const extrudeVector = centroid.clone().normalize().multiplyScalar(height);
  const topPoints = basePoints.map(v => v.clone().add(extrudeVector));

  const data2D = [];
  ring.forEach(([lon, lat]) => data2D.push(lon, lat));
  const indices = earcut(data2D);

  const allVertices = [];
  const allIndices = [];
  const n = basePoints.length;
  const offsetBase = 0;
  const offsetTop = n;

  basePoints.forEach(v => allVertices.push(v.x, v.y, v.z));
  topPoints.forEach(v => allVertices.push(v.x, v.y, v.z));

  // base
  indices.forEach(i => allIndices.push(offsetBase + i));
  // top (reverse)
  for (let i = indices.length - 1; i >= 0; i--) {
    allIndices.push(offsetTop + indices[i]);
  }
  // sides
  for (let i = 0; i < n; i++) {
    const i0 = offsetBase + i;
    const i1 = offsetBase + (i + 1) % n;
    const i2 = offsetTop + i;
    const i3 = offsetTop + (i + 1) % n;
    allIndices.push(i0, i2, i1);
    allIndices.push(i1, i2, i3);
  }

  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute("position", new THREE.Float32BufferAttribute(allVertices, 3));
  geometry.setIndex(allIndices);
  geometry.computeVertexNormals();
  return geometry;
}

/* ------------------------------------------------------------
   SMOOTH BORDER (LineLoop) - basée sur ring lon/lat
------------------------------------------------------------ */
function createSmoothBorder(ring, R, radialOffset) {
  const points = [];
  ring.forEach(([lon, lat]) => {
    const v = lonLatToVector3(lon, lat, R);
    v.normalize().multiplyScalar(R + radialOffset);
    points.push(v);
  });

  const geometry = new THREE.BufferGeometry().setFromPoints(points);
  return new THREE.LineLoop(geometry, borderMaterial);
}

/* ------------------------------------------------------------
   DATA LOAD
------------------------------------------------------------ */
const countriesGroup = new THREE.Group();
globeGroup.add(countriesGroup);

function addCountryMesh(ring, countryName, isOuterRing) {
  const geometry = createPrismExtrusion(ring, CONFIG.radius, CONFIG.extrudeDepth);

  const material = baseCountryMaterial.clone();
  const mesh = new THREE.Mesh(geometry, material);

  // On stocke tout ce qui est nécessaire pour reconstruire proprement
  mesh.userData = {
    name: countryName,
    ring: ring,
    isOuter: isOuterRing
  };

  // Bordure (uniquement si ring extérieur)
  if (isOuterRing) {
    const borderLine = createSmoothBorder(ring, CONFIG.radius, CONFIG.borderOffset);
    borderLine.userData = { kind: "border" };
    mesh.add(borderLine);
  }

  countriesGroup.add(mesh);
}

fetch(CONFIG.geoJsonUrl)
  .then(res => res.json())
  .then(data => {
    data.features.forEach(feature => {
      const geom = feature.geometry;
      const polys = (geom.type === "Polygon") ? [geom.coordinates] : geom.coordinates;
      const countryName = feature.properties.name || "Unknown";

      polys.forEach(polygon => {
        polygon.forEach((ring, ringIndex) => {
          const isOuterRing = ringIndex === 0; // ring 0 = côte/extérieur
          addCountryMesh(ring, countryName, isOuterRing);
        });
      });
    });
  })
  .catch(err => console.error(err));

/* ------------------------------------------------------------
   STARFIELD
------------------------------------------------------------ */
function createStarsGLSL() {
  const starsGeom = new THREE.BufferGeometry();
  const count = 3000;
  const pos = new Float32Array(count * 3);
  const sizes = new Float32Array(count);

  for (let i = 0; i < count; i++) {
    const r = 50 + Math.random() * 50;
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos(2 * Math.random() - 1);

    pos[i * 3] = r * Math.sin(phi) * Math.cos(theta);
    pos[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
    pos[i * 3 + 2] = r * Math.cos(phi);

    sizes[i] = 1.0 + Math.random() * 2.0;
  }

  starsGeom.setAttribute("position", new THREE.BufferAttribute(pos, 3));
  starsGeom.setAttribute("size", new THREE.BufferAttribute(sizes, 1));

  const starsMat = new THREE.ShaderMaterial({
    vertexShader: starsVS,
    fragmentShader: starsFS,
    uniforms: { color: { value: new THREE.Color(0xffffff) } },
    transparent: true
  });

  return new THREE.Points(starsGeom, starsMat);
}
scene.add(createStarsGLSL());

/* ------------------------------------------------------------
   COCKPIT WIRING (IDs = HTML nettoyé)
------------------------------------------------------------ */
function bindInput(id, callback, displayId = null) {
  const el = document.getElementById(id);
  if (!el) return;

  el.addEventListener("input", (e) => {
    let val = (e.target.type === "checkbox") ? e.target.checked : e.target.value;
    if (e.target.type === "range") val = parseFloat(val);

    callback(val);

    if (displayId) {
      const d = document.getElementById(displayId);
      if (d) d.innerText = e.target.value;
    }
  });
}

function syncDisplay(id, displayId) {
  const el = document.getElementById(id);
  const d = document.getElementById(displayId);
  if (!el || !d) return;
  d.innerText = el.value;
}

/* --- Rebuild helpers --- */
function rebuildExtrusion(newHeight) {
  // extrusion: met à jour uniquement la géométrie des meshes (les bordures ne dépendent pas de height)
  countriesGroup.children.forEach(mesh => {
    if (!(mesh instanceof THREE.Mesh)) return;
    if (!mesh.userData || !mesh.userData.ring) return;

    const newGeo = createPrismExtrusion(mesh.userData.ring, CONFIG.radius, newHeight);
    mesh.geometry.dispose();
    mesh.geometry = newGeo;
  });
}

function rebuildRadius(newRadius) {
  // 1) ocean: recréer la géométrie (pas de scale approximatif)
  ocean.geometry.dispose();
  ocean.geometry = new THREE.SphereGeometry(newRadius - 0.02, 64, 64);

  // 2) atmosphere: recréer la géométrie
  atmosphere.geometry.dispose();
  atmosphere.geometry = new THREE.SphereGeometry(newRadius + 0.8, 64, 64);

  // 3) pays + bordures
  countriesGroup.children.forEach(mesh => {
    if (!(mesh instanceof THREE.Mesh)) return;
    if (!mesh.userData || !mesh.userData.ring) return;

    // mesh géométrie
    const newGeo = createPrismExtrusion(mesh.userData.ring, newRadius, CONFIG.extrudeDepth);
    mesh.geometry.dispose();
    mesh.geometry = newGeo;

    // bordure si outer
    if (mesh.userData.isOuter) {
      const existing = mesh.children.find(ch => ch.userData && ch.userData.kind === "border");
      if (existing) {
        existing.geometry.dispose();
        mesh.remove(existing);
      }
      const borderLine = createSmoothBorder(mesh.userData.ring, newRadius, CONFIG.borderOffset);
      borderLine.userData = { kind: "border" };
      mesh.add(borderLine);
    }
  });
}

/* --- Geometry --- */
bindInput("geo-extrude", (val) => {
  CONFIG.extrudeDepth = val;
  rebuildExtrusion(val);
}, "val-geo-extrude");

bindInput("geo-radius", (val) => {
  CONFIG.radius = val;
  rebuildRadius(val);
}, "val-geo-radius");

bindInput("geo-atmo-rad", (val) => {
  // atmo radius = scale relative (0.8 par défaut)
  const s = 1 + (val / 0.8);
  atmosphere.scale.set(s, s, s);
}, "val-geo-atmo-rad");

/* --- Glass material --- */
function updateMaterial(prop, val) {
  if (baseCountryMaterial[prop] === undefined) return;

  baseCountryMaterial[prop] = val;
  countriesGroup.children.forEach(mesh => {
    if (mesh.material && mesh.material[prop] !== undefined) {
      mesh.material[prop] = val;
    }
  });
}

bindInput("glass-trans", (v) => updateMaterial("transmission", v), "val-glass-trans");
bindInput("glass-rough", (v) => updateMaterial("roughness", v), "val-glass-rough");
bindInput("glass-metal", (v) => updateMaterial("metalness", v), "val-glass-metal");
bindInput("glass-clear", (v) => updateMaterial("clearcoat", v), "val-glass-clear");

/* --- Atmosphere (UI nettoyée: Intensity + Color Out uniquement) --- */
bindInput("corona-int", (v) => {
  coronaMaterial.uniforms.intensity.value = parseFloat(v);
}, "val-corona-int");

bindInput("corona-col1", (v) => {
  coronaMaterial.uniforms.color1.value = new THREE.Color(v);
});

/* --- Lighting --- */
bindInput("light-sun-int", (v) => { sunLight.intensity = parseFloat(v); });
bindInput("light-sun-col", (v) => { sunLight.color.set(v); });
bindInput("light-rim-int", (v) => { rimLight.intensity = parseFloat(v); });
bindInput("light-rim-col", (v) => { rimLight.color.set(v); });
bindInput("light-amb-int", (v) => { ambientLight.intensity = parseFloat(v); });

/* --- Env / Camera --- */
bindInput("env-fog", (v) => { scene.fog.density = parseFloat(v); });
bindInput("env-rot", (v) => { CONFIG.rotateSpeed = parseFloat(v); });
bindInput("cam-fov", (v) => {
  camera.fov = parseFloat(v);
  camera.updateProjectionMatrix();
});

/* --- Init: synchroniser les spans au chargement --- */
syncDisplay("geo-extrude", "val-geo-extrude");
syncDisplay("geo-radius", "val-geo-radius");
syncDisplay("geo-atmo-rad", "val-geo-atmo-rad");
syncDisplay("glass-trans", "val-glass-trans");
syncDisplay("glass-rough", "val-glass-rough");
syncDisplay("glass-metal", "val-glass-metal");
syncDisplay("glass-clear", "val-glass-clear");
syncDisplay("corona-int", "val-corona-int");

/* ------------------------------------------------------------
   LOOP
------------------------------------------------------------ */
const fpsEl = document.getElementById("fps");
let lastTime = 0;

function animate(time) {
  requestAnimationFrame(animate);

  const dt = time - lastTime;
  lastTime = time;
  if (dt > 0 && Math.random() > 0.95) fpsEl.innerText = Math.round(1000 / dt);

  // Raycaster: pays uniquement (pas les LineLoop enfants)
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(countriesGroup.children, false);

  // reset hover
  hoveredMeshes.forEach(mesh => {
    if (mesh && mesh.material) {
      mesh.material.emissive.setHex(0x000000);
      mesh.material.emissiveIntensity = 0;
    }
  });
  hoveredMeshes.clear();

  if (intersects.length > 0) {
    const object = intersects[0].object;

    object.material.emissive.setHex(0x00ffcc);
    object.material.emissiveIntensity = 0.5;
    hoveredMeshes.add(object);

    if (object.userData && object.userData.name) {
      labelEl.innerText = object.userData.name;
      labelEl.style.display = "block";
      labelEl.style.borderColor = "#00ffcc";
      labelEl.style.color = "#00ffcc";
      labelEl.style.boxShadow = "0 0 15px rgba(0, 255, 204, 0.5)";

      const point = intersects[0].point.clone();
      point.project(camera);

      const x = (point.x * 0.5 + 0.5) * window.innerWidth;
      const y = (-(point.y * 0.5) + 0.5) * window.innerHeight;

      labelEl.style.left = `${x}px`;
      labelEl.style.top = `${y}px`;
    }
  } else {
    labelEl.style.display = "none";
  }

  const t = time * 0.001;
  coronaMaterial.uniforms.time.value = t;

  controls.update();

  if (CONFIG.autoRotate) {
    globeGroup.rotation.y += CONFIG.rotateSpeed;
  }

  renderer.render(scene, camera);
}
animate(0);

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>