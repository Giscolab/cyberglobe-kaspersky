<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CyberGlobe - Ultimate Fusion</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; width: 100vw; height: 100vh; outline: none; }
        
        #ui-container {
            position: absolute; top: 20px; left: 20px;
            color: #00ffcc; pointer-events: none; z-index: 10;
            text-shadow: 0 0 5px rgba(0, 255, 204, 0.6);
        }
        h1 { margin: 0; font-size: 1.3rem; text-transform: uppercase; letter-spacing: 2px; }
        p { margin: 5px 0; font-size: 0.8rem; opacity: 0.9; color: #aaddff; }
        .badge { 
            display: inline-block; padding: 2px 6px; 
            background: rgba(0, 255, 204, 0.15); 
            border: 1px solid #00ffcc; 
            font-size: 0.7rem; margin-left: 10px; border-radius: 3px;
            box-shadow: 0 0 10px rgba(0,255,204,0.2);
            font-weight: bold;
        }

        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }

        #controls {
            position: absolute; bottom: 30px; left: 30px;
            background: rgba(0, 5, 10, 0.9);
            border: 1px solid rgba(0, 255, 204, 0.3);
            padding: 20px; border-radius: 4px;
            color: #fff; font-size: 0.85rem; pointer-events: auto;
            backdrop-filter: blur(10px); max-width: 320px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
        }
        .control-row { 
            display: flex; justify-content: space-between; align-items: center; 
            margin-bottom: 15px; 
        }
        label { font-weight: bold; color: #88ccff; font-size: 0.75rem; text-transform: uppercase;}
        input[type="range"] { 
            width: 150px; accent-color: #00ffcc; cursor: pointer;
        }
        button {
            width: 100%; padding: 8px;
            background: rgba(0, 255, 204, 0.1); border: 1px solid #00ffcc;
            color: #00ffcc; cursor: pointer; text-transform: uppercase; letter-spacing: 1px; font-size: 0.75rem;
            transition: all 0.3s ease;
        }
        button:hover { background: #00ffcc; color: #000; box-shadow: 0 0 20px #00ffcc; letter-spacing: 2px;}
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/earcut@2.2.3/dist/earcut.min.js"></script>
</head>
<body>

    <div id="ui-container">
        <h1>CyberGlobe <span class="badge">ULTIMATE FUSION</span></h1>
        <p id="status" class="loading">Initializing Glass Engine...</p>
        <p>FPS: <span id="fps">0</span> | Entities: <span id="tris">0</span></p>
    </div>

    <div id="controls">
        <div class="control-row">
            <label>Extrusion Height</label>
            <input type="range" id="extrude-slider" min="0.01" max="0.4" step="0.01" value="0.12">
        </div>
        <div class="control-row">
            <label>Glass Opacity</label>
            <input type="range" id="trans-slider" min="0" max="0.95" step="0.05" value="0.6">
        </div>
        <div class="control-row">
            <label>Land Color (Tone)</label>
            <input type="range" id="tone-slider" min="0" max="1" step="0.01" value="0.3">
        </div>
        <div class="control-row">
            <label>Grid Speed</label>
            <input type="range" id="grid-slider" min="0" max="0.02" step="0.001" value="0.002">
        </div>
        <div class="control-row">
            <label>Corona (Halo)</label>
            <input type="range" id="corona-slider" min="0" max="3" step="0.1" value="1.5">
        </div>
        <div class="control-row">
            <label>Rotation</label>
            <button id="toggle-rot">Pause / Play</button>
        </div>
    </div>

    <script>
        // ------------------------------------------------------------
        // CONFIG
        // ------------------------------------------------------------
        const CONFIG = {
            radius: 5,
            extrudeDepth: 0.05,
            colorOcean: 0x020205,
            colorGlow: 0x00ffcc,
            geoJsonUrl: 'https://raw.githubusercontent.com/johan/world.geo.json/master/countries.geo.json',
            autoRotate: true,
            rotateSpeed: 0.0005
        };

        // ------------------------------------------------------------
        // SCENE
        // ------------------------------------------------------------
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.015);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 16;
        camera.position.y = 4;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.setClearColor(0x000000);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enablePan = false;
        controls.minDistance = 6;
        controls.maxDistance = 30;

        // ------------------------------------------------------------
        // LIGHTING (Ambient + Cyber)
        // ------------------------------------------------------------
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.15);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
        sunLight.position.set(10, 10, 10);
        scene.add(sunLight);

        const blueLight = new THREE.DirectionalLight(0x0088ff, 0.5);
        blueLight.position.set(-5, 0, 5);
        scene.add(blueLight);

        const rimLight = new THREE.SpotLight(0x00ffff, 4.0);
        rimLight.position.set(-15, 5, -10);
        rimLight.lookAt(0,0,0);
        scene.add(rimLight);

        // ------------------------------------------------------------
        // SHADERS (STARS + CORONA + GRID)
        // ------------------------------------------------------------

        // 1. STARS SHADER
        const starsVS = `
            attribute float size;
            void main() {
                gl_PointSize = size;
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;
        const starsFS = `
            uniform vec3 color;
            void main() {
                vec2 coord = gl_PointCoord - vec2(0.5);
                if(length(coord) > 0.5) discard;
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // 2. CORONA SHADER (With Noise)
        const coronaVS = `
            varying vec3 vWorldPos;
            varying vec3 vWorldNormal;
            void main() {
                vec4 wp = modelMatrix * vec4(position, 1.0);
                vWorldPos = wp.xyz;
                vWorldNormal = normalize(mat3(modelMatrix) * normal);
                gl_Position = projectionMatrix * viewMatrix * wp;
            }
        `;
        const coronaFS = `
            varying vec3 vWorldPos;
            varying vec3 vWorldNormal;
            uniform vec3 color0;
            uniform vec3 color1;
            uniform float intensity;
            uniform float time;

            float random(vec2 st) {
                return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
            }

            void main() {
                vec3 V = normalize(cameraPosition - vWorldPos);
                float ndv = max(dot(normalize(vWorldNormal), V), 0.0);
                float glow = pow(1.0 - ndv, 2.5);

                float noise = random(vec2(gl_FragCoord.xy * 0.01 + time * 0.1));
                float smoke = 0.5 + 0.5 * noise;

                vec3 finalColor = mix(color0, color1, glow) + 0.2 * smoke * glow;
                gl_FragColor = vec4(finalColor, 1.0) * glow * intensity;
            }
        `;

        // 3. MAP GRID SHADER (Animated Tech Grid)
        const mapGridVS = `
            varying vec3 vWorldPos;
            void main() {
                vec4 wp = modelMatrix * vec4(position, 1.0);
                vWorldPos = wp.xyz;
                gl_Position = projectionMatrix * viewMatrix * wp;
            }
        `;
        const mapGridFS = `
            varying vec3 vWorldPos;
            uniform vec3 color0;
            uniform vec3 color1;
            uniform float time;
            uniform float pattern_scale;
            uniform float radius;

            void main() {
                vec3 p = normalize(vWorldPos);
                float lon = atan(p.z, p.x);
                float lat = asin(p.y);

                vec2 uv;
                uv.x = (lon + 3.14159265) / (2.0 * 3.14159265);
                uv.y = (lat + 1.57079633) / 3.14159265;

                vec2 g = uv * pattern_scale;
                g.y += time;

                float gridX = step(0.98, fract(g.x));
                float gridY = step(0.98, fract(g.y));
                float grid = max(gridX, gridY);

                vec3 finalColor = mix(color0, color1, grid);
                float alpha = grid * 0.6;
                gl_FragColor = vec4(finalColor, alpha);
            }
        `;

        // ------------------------------------------------------------
        // MATERIALS
        // ------------------------------------------------------------
        
        // Matériau Verre (MeshPhysical pour l'effet Glass Opacity)
        const countryMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x00ffcc,
            metalness: 0.2,
            roughness: 0.1,
            transmission: 0.6,     // Contrôlé par slider
            thickness: 0.2,
            clearcoat: 1.0,
            clearcoatRoughness: 0.0,
            side: THREE.DoubleSide,
            transparent: true,
            polygonOffset: true,
            polygonOffsetFactor: 1, // Pousse derrière la grille
            polygonOffsetUnits: 1
        });

        // Matériau Océan
        const oceanMat = new THREE.MeshPhysicalMaterial({
            color: 0x020408,
            metalness: 0.5,
            roughness: 0.4,
            clearcoat: 0.3,
        });

        // Matériau Corona
        const coronaMaterial = new THREE.ShaderMaterial({
            vertexShader: coronaVS,
            fragmentShader: coronaFS,
            uniforms: {
                color0: { value: new THREE.Color(0x000000) },
                color1: { value: new THREE.Color(0x00ffff) },
                intensity: { value: 1.5 },
                time: { value: 0 }
            },
            side: THREE.BackSide,
            blending: THREE.AdditiveBlending,
            transparent: true,
            depthWrite: false
        });

        // Matériau Grille (Superposé)
        const mapGridMaterial = new THREE.ShaderMaterial({
            vertexShader: mapGridVS,
            fragmentShader: mapGridFS,
            uniforms: {
                color0: { value: new THREE.Color(0x000000) },
                color1: { value: new THREE.Color(0x00ffff) },
                time: { value: 0 },
                pattern_scale: { value: 20.0 },
                radius: { value: CONFIG.radius }
            },
            transparent: true,
            side: THREE.FrontSide,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            depthTest: true
        });

        // ------------------------------------------------------------
        // GLOBE BASE
        // ------------------------------------------------------------
        const globeGroup = new THREE.Group();
        scene.add(globeGroup);

        const ocean = new THREE.Mesh(
            new THREE.SphereGeometry(CONFIG.radius - 0.02, 64, 64),
            oceanMat
        );
        globeGroup.add(ocean);

        // Atmosphère
        const atmoGeom = new THREE.SphereGeometry(CONFIG.radius + 0.8, 64, 64);
        const atmosphere = new THREE.Mesh(atmoGeom, coronaMaterial);
        scene.add(atmosphere);

        // ------------------------------------------------------------
        // --- GÉOMÉTRIE : PRISMATIQUE PLANE (VASTURIANO STYLE) ---
        // ------------------------------------------------------------
        function lonLatToVector3(lon, lat, radius) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);
            const x = -(radius * Math.sin(phi) * Math.cos(theta));
            const z = (radius * Math.sin(phi) * Math.sin(theta));
            const y = (radius * Math.cos(phi));
            return new THREE.Vector3(x, y, z);
        }

        function ringArea2D(ring) {
            let a = 0;
            for (let i = 0, n = ring.length; i < n; i++) {
                const [x1, y1] = ring[i];
                const [x2, y2] = ring[(i + 1) % n];
                a += x1 * y2 - x2 * y1;
            }
            return a * 0.5;
        }

        function normalizeWinding(polygonRings) {
            const outer = polygonRings[0].slice();
            const holes = polygonRings.slice(1).map(ring => ring.slice());

            if (ringArea2D(outer) < 0) outer.reverse();
            for (const hole of holes) {
                if (ringArea2D(hole) > 0) hole.reverse();
            }
            return [outer, ...holes];
        }

        function createPrismExtrusionWithHoles(rings, R, height) {
            const basePoints = [];
            const data2D = [];
            const holeIndices = [];

            let vertCount = 0;
            rings.forEach((ring, ringIndex) => {
                if (ringIndex > 0) holeIndices.push(vertCount);
                ring.forEach(([lon, lat]) => {
                    basePoints.push(lonLatToVector3(lon, lat, R));
                    data2D.push(lon, lat);
                    vertCount++;
                });
            });

            const centroid = new THREE.Vector3();
            for (const v of basePoints) centroid.add(v);
            centroid.divideScalar(basePoints.length);
            const extrudeVector = centroid.clone().normalize().multiplyScalar(height);

            const topPoints = basePoints.map(v => v.clone().add(extrudeVector));

            const indices = earcut(data2D, holeIndices);

            const allVertices = [];
            const allIndices = [];

            const n = basePoints.length;
            const offsetBase = 0;
            const offsetTop = n;

            basePoints.forEach(v => allVertices.push(v.x, v.y, v.z));
            topPoints.forEach(v => allVertices.push(v.x, v.y, v.z));

            for (let i = 0; i < indices.length; i++) {
                allIndices.push(offsetBase + indices[i]);
            }

            for (let i = indices.length - 1; i >= 0; i--) {
                allIndices.push(offsetTop + indices[i]);
            }

            let ringStart = 0;
            rings.forEach((ring) => {
                const ringLen = ring.length;
                for (let i = 0; i < ringLen; i++) {
                    const i0 = ringStart + i;
                    const i1 = ringStart + (i + 1) % ringLen;

                    const b0 = offsetBase + i0;
                    const b1 = offsetBase + i1;
                    const t0 = offsetTop + i0;
                    const t1 = offsetTop + i1;

                    allIndices.push(b0, t0, b1);
                    allIndices.push(b1, t0, t1);
                }
                ringStart += ringLen;
            });

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(allVertices, 3));
            geometry.setIndex(allIndices);
            geometry.computeVertexNormals();

            return geometry;
        }

        // ------------------------------------------------------------
        // CHARGEMENT DONNÉES + FUSION LAYERS
        // ------------------------------------------------------------
        const countriesGroup = new THREE.Group();
        globeGroup.add(countriesGroup);
        
        let triCount = 0;
        const statusEl = document.getElementById('status');
        const trisEl = document.getElementById('tris');
        let geoData = null;

        function clearGroup(group) {
            while (group.children.length) {
                const obj = group.children.pop();
                obj.traverse((node) => {
                    if (node.geometry) node.geometry.dispose();
                    if (node.material) {
                        if (Array.isArray(node.material)) {
                            node.material.forEach(material => material.dispose());
                        } else {
                            node.material.dispose();
                        }
                    }
                });
            }
        }

        function buildCountries(data) {
            clearGroup(countriesGroup);
            triCount = 0;

            data.features.forEach(feature => {
                const geom = feature.geometry;
                const polys = (geom.type === "Polygon") ? [geom.coordinates] : geom.coordinates;

                polys.forEach(polygon => {
                    const rings = normalizeWinding(polygon);
                    const geometry = createPrismExtrusionWithHoles(rings, CONFIG.radius, CONFIG.extrudeDepth);

                    const mesh = new THREE.Mesh(geometry, countryMaterial);
                    countriesGroup.add(mesh);
                    triCount += geometry.index.count / 3;

                    const gridMesh = new THREE.Mesh(geometry, mapGridMaterial);
                    gridMesh.renderOrder = 1;
                    mesh.renderOrder = 0;
                    mesh.add(gridMesh);

                    const edges = new THREE.EdgesGeometry(geometry);
                    const line = new THREE.LineSegments(
                        edges,
                        new THREE.LineBasicMaterial({
                            color: 0x00ffff,
                            transparent: true,
                            opacity: 0.2,
                            depthWrite: false
                        })
                    );
                    line.renderOrder = 2;
                    mesh.add(line);
                });
            });

            trisEl.innerText = (triCount / 1000).toFixed(1) + "k";
        }

        fetch(CONFIG.geoJsonUrl)
            .then(res => res.json())
            .then(data => {
                statusEl.textContent = "Fusion Complete: Prism + Grid + Corona";
                statusEl.style.color = "#00ffcc";
                geoData = data;
                buildCountries(geoData);
                setTimeout(() => { statusEl.style.opacity = 0; }, 3000);
            })
            .catch(err => {
                console.error(err);
                statusEl.textContent = "Error Loading Data";
                statusEl.style.color = "red";
            });

        // ------------------------------------------------------------
        // STARFIELD (GLSL)
        // ------------------------------------------------------------
        function createStarsGLSL() {
            const starsGeom = new THREE.BufferGeometry();
            const count = 3000;
            const pos = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            for(let i=0; i<count; i++) {
                const r = 50 + Math.random() * 50;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                pos[i*3] = r * Math.sin(phi) * Math.cos(theta);
                pos[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                pos[i*3+2] = r * Math.cos(phi);
                sizes[i] = 1.0 + Math.random() * 2.0;
            }
            starsGeom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            starsGeom.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const starsMat = new THREE.ShaderMaterial({
                vertexShader: starsVS,
                fragmentShader: starsFS,
                uniforms: { color: { value: new THREE.Color(0xffffff) } },
                transparent: true
            });

            return new THREE.Points(starsGeom, starsMat);
        }
        scene.add(createStarsGLSL());

        // ------------------------------------------------------------
        // UI & CONTROLS (TOUS LES SLIDERS)
        // ------------------------------------------------------------
        
        // 1. Grid Speed
        let gridSpeed = parseFloat(document.getElementById('grid-slider').value);
        document.getElementById('grid-slider').addEventListener('input', (e) => {
            gridSpeed = parseFloat(e.target.value);
        });

        // 2. Corona (Halo)
        document.getElementById('corona-slider').addEventListener('input', (e) => {
            coronaMaterial.uniforms.intensity.value = parseFloat(e.target.value);
        });

        // 3. Land Color (Tone) - Mix entre Sombre et Cyan
        document.getElementById('tone-slider').addEventListener('input', (e) => {
            const t = parseFloat(e.target.value);
            const colDark = new THREE.Color(0x001133);
            const colLight = new THREE.Color(0x00ffcc);
            countryMaterial.color.copy(colDark).lerp(colLight, t);
        });

        // 4. Glass Opacity (Transmission)
        document.getElementById('trans-slider').addEventListener('input', (e) => {
            countryMaterial.transmission = parseFloat(e.target.value);
        });

        // 5. Extrusion Height
        const extrudeSlider = document.getElementById('extrude-slider');
        extrudeSlider.addEventListener('input', (e) => {
            CONFIG.extrudeDepth = parseFloat(e.target.value);
            if (geoData) buildCountries(geoData);
        });

        // 6. Rotation
        document.getElementById('toggle-rot').addEventListener('click', (e) => {
            CONFIG.autoRotate = !CONFIG.autoRotate;
            e.target.innerText = CONFIG.autoRotate ? "Pause / Play" : "Pause / Play";
        });

        // ------------------------------------------------------------
        // LOOP
        // ------------------------------------------------------------
        const fpsEl = document.getElementById('fps');
        let lastTime = 0;
        let gridTime = 0;

        function animate(time) {
            requestAnimationFrame(animate);
            
            const dt = time - lastTime;
            lastTime = time;
            if(Math.random()>0.95) fpsEl.innerText = Math.round(1000/dt);

            // Update Uniforms Temps
            const t = time * 0.001;
            coronaMaterial.uniforms.time.value = t;
            
            // Animation Grille (continue si slider > 0)
            if (gridSpeed > 0) {
                gridTime += gridSpeed;
                mapGridMaterial.uniforms.time.value = gridTime;
            }

            controls.update();

            if (CONFIG.autoRotate) {
                globeGroup.rotation.y += CONFIG.rotateSpeed;
            }

            renderer.render(scene, camera);
        }
        animate(0);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
